#+TITLE: JSONB
#+AUTHOR: M. Surmashev @muradbei
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+PROPERTY: header-args:sql :engine postgresql :dbport 5400 :dbhost localhost :dbuser postgres :dbpassword postgres :database postgres

* Intro                                                            :noexport:

  [[./jsonb.png]]

* Table of Contents                                                   :TOC_3:
- [[#install][Install]]
- [[#jsonb][JSONB]]
  - [[#json-vs-jsonb][JSON vs JSONB]]
- [[#basic-operators-and-functions][Basic operators and functions]]
  - [[#create-jsonb][Create JSONB]]
  - [[#predicates][Predicates]]
  - [[#mutate-jsonb][Mutate jsonb]]
  - [[#extract-value][Extract value]]
  - [[#iterators][Iterators]]
  - [[#aggregates][Aggregates]]
- [[#jsquery][Jsquery]]
  - [[#jsquery-syntax][Jsquery syntax]]
    - [[#simple-expression][Simple expression]]
    - [[#path-select][Path select]]
- [[#jsonpath][JsonPath]]
  - [[#sqljson-path-language][SQL/JSON Path Language]]
    - [[#strict-and-lax-modes][Strict And Lax Modes]]
    - [[#operators-and-methods][Operators and Methods]]
    - [[#filter-expression][Filter Expression]]
    - [[#sqljson-regular-expressions][SQL/JSON Regular Expressions]]
- [[#json-knife][Json knife]]
  - [[#functions][Functions]]
- [[#class-work][Class work]]
  - [[#ansver][Ansver]]

* Install

  Run docker container vith PostgreSQL 12:
  #+name: Run db
  #+BEGIN_SRC bash
    docker-compose up -d
  #+END_SRC

  Check connection:
  #+name: Check connection
  #+BEGIN_SRC bash :results value drawer
    psql -h localhost -p 5400 -U postgres -c 'select 1';
  #+END_SRC

  Ensure connection via psql:
  #+name: Check connection and list databases
  #+BEGIN_SRC sql
    \l
  #+END_SRC

* JSONB

   [[https://postgrespro.ru/docs/postgrespro/10/datatype-json?lang=en][JSON/JSONB]] - JSON data types are for storing JSON (JavaScript Object Notation) data, as specified in [[https://tools.ietf.org/html/rfc7159?lang=en][RFC 7159]] .

   #+BEGIN_QUOTE
   ⚡ [[https://www.postgresql.org/docs/13/functions-json.html][JSON Functions and Operators]] - functions and operators for processing and creating JSON data
   #+END_QUOTE

** JSON vs JSONB

 - ~JSON~ plain text json
 - ~JSONB~ binary json format
   - All keys unique
   - All keys sorted

*Exmaple:*

=JSON= can containing duplicate keys

  #+name: Cast to JSON
  #+BEGIN_SRC sql
    select '{"name": "Bob", "name": "John"}'::json
  #+END_SRC

  #+RESULTS: Cast to JSON
  | json                            |
  |---------------------------------|
  | {"name": "Bob", "name": "John"} |

=JSONB= replace double key

  #+name: Cast to JSONB
  #+BEGIN_SRC sql
    select '{"name": "Bob", "name": "John"}'::jsonb
  #+END_SRC

  #+RESULTS: Cast to JSONB
  | jsonb            |
  |------------------|
  | {"name": "John"} |

* Basic operators and functions
** Create JSONB

  =::JSONB= - cast string as json/jsonb type

  #+BEGIN_SRC sql
    select '{"name": "Bob"}'::JSONB;
  #+END_SRC

  #+RESULTS:
  | jsonb           |
  |-----------------|
  | {"name": "Bob"} |


  =jsonb_build_array= - create json/jsonb contains array

  #+BEGIN_SRC sql
    select jsonb_build_array(1, 2, 3, 'Bob');
  #+END_SRC

  #+RESULTS:
  | jsonb_build_array |
  |-------------------|
  | [1, 2, 3, "Bob"]  |


  =jsonb_build_object= - create json/jsonb object

  #+BEGIN_SRC sql
    select jsonb_build_object('name', 'Bob', 'family', 'Smith');
  #+END_SRC

** Predicates

  =?= - Does the string exist as a top-level key within the JSON value
  #+BEGIN_SRC sql
    select '{"name": "Bob"}'::JSONB ? 'name';
  #+END_SRC

    #+RESULTS:
    | ?column? |
    |----------|
    | t        |

  =@>= - Does the left JSON value contain the right JSON
  #+BEGIN_SRC sql
    select '{"name": "Bob", "family": "Smith"}'::jsonb
	     @> '{"name": "Bob"}'::jsonb ;
  #+END_SRC

   #+RESULTS:
   | ?column? |
   |----------|
   | t        |

** Mutate jsonb

  =||= - Concatenate two jsonb values into a new jsonb value
  #+BEGIN_SRC sql
    select '{"name": "Bob"}'::JSONB || '{"family": "Smith"}'::JSONB;
  #+END_SRC

  #+RESULTS:
  | ?column?                           |
  |------------------------------------|
  | {"name": "Bob", "family": "Smith"} |

  =-= - Delete key/value pair or string element from left operand
  #+BEGIN_SRC sql
    select '{"name": "Bob", "family": "Smith"}'::jsonb - 'name'
  #+END_SRC

  #+RESULTS:
  | ?column?            |
  |---------------------|
  | {"family": "Smith"} |

  =jsonb_set= - Insert new value by path
  #+BEGIN_SRC sql
    select jsonb_set('{"f1":1,"f2":null}', '{f1}', '[2,3,4]') ;
  #+END_SRC

** Extract value

   =-> ->> #> #>>= - Default value extractors

   | *Operator* | *Argument*      | *Result* |
   |----------+---------------+--------|
   | ~->~       | integer, text | jsonb  |
   | ~->>~      | integer, text | text   |
   | ~#>~       | text[]        | jsonb  |
   | ~#>>~      | text[]        | text   |

   #+BEGIN_SRC sql
     select
       x -> 1 as "->"
       , x->> 1 as "->>"
       , x#> '{0, name}' as "->>"
       , x#>> '{0, name}' as "->>"
       from (values ('[{"name": "Joe"}, {"name": "Bob"}]'::jsonb)) as t(x);
     select
       pg_typeof(x -> 1) as "->"
       , pg_typeof(x->> 1) as "->>"
       , pg_typeof(x#> '{0, name}') as "->>"
       , pg_typeof(x#>> '{0, name}') as "->>"
       from (values ('[{"name": "Joe"}, {"name": "Bob"}]'::jsonb)) as t(x) ;
   #+END_SRC

   #+RESULTS:
   | ->              | ->>             | ->>   | ->>  |
   |-----------------+-----------------+-------+------|
   | {"name": "Bob"} | {"name": "Bob"} | "Joe" | Joe  |
   | ->              | ->>             | ->>   | ->>  |
   | jsonb           | text            | jsonb | text |

** Iterators

   =jsonb_array_elements= - populate records from json/jsonb array
   #+BEGIN_SRC sql
     select jsonb_array_elements_text('[1, 2, 3, 4, 5]'::jsonb) itm
   #+END_SRC

   #+RESULTS:
   | itm |
   |-----|
   |   1 |
   |   2 |
   |   3 |
   |   4 |
   |   5 |

   #+BEGIN_SRC sql
     select sum(x::int)
       from (select jsonb_array_elements_text('[1, 2, 3, 4, 5]'::jsonb)) t(x)
   #+END_SRC

   #+RESULTS:
   | sum |
   |-----|
   |  15 |

   =jsonb_each= - populate key/value records from jsonb object
   #+BEGIN_SRC sql
     select *
       from jsonb_each('{"name": "Joe", "family": "Smith"}'::jsonb)
   #+END_SRC

   #+RESULTS:
   | key    | value   |
   |--------+---------|
   | name   | "Joe"   |
   | family | "Smith" |

** Aggregates

   =jsonb_agg= - aggregate tuples into jsonb array
   #+BEGIN_SRC sql
     select jsonb_agg(x)
       from generate_series(1, 5) t(x)
   #+END_SRC

   #+RESULTS:
   | jsonb_agg       |
   |-----------------|
   | [1, 2, 3, 4, 5] |

   =jsonb_object_agg= - aggregate new jsonb object
   #+BEGIN_SRC sql
     select jsonb_pretty(jsonb_object_agg(x, x))
       from generate_series(1,
   #+END_SRC

   #+RESULTS:
   | jsonb_pretty |
   |--------------|
   | {            |
   | "1": 1,      |
   | "2": 2,      |
   | "3": 3,      |
   | "4": 4,      |
   | "5": 5       |
   | }            |

* Jsquery

  [[https://github.com/postgrespro/jsquery][JsQuery]] - json query language with ~GIN~ indexing support

  JSquey not default extension, and need to be installed

  #+BEGIN_SRC sql
    create extension if not exists jsquery;
  #+END_SRC

  JSquey use ~@@~ operator

  #+BEGIN_QUOTE
 ⚡ In PG12 ~jsonpath~ use the same operator ~@@~
    For this reason you should explicitly cast to =::jsqury=

 ⚡ ~JsQuery~ - only as predicate
  #+END_QUOTE

  *Example:*
  #+BEGIN_SRC sql
    select '{"name": "Bob"}'::jsonb @@ ('name = Bob')::jsquery
  #+END_SRC

  #+RESULTS:
  | ?column? |
  |----------|
  | t        |

  #+BEGIN_SRC sql
    select '[{"name": "Bob"}, {"name": "John"}]'::jsonb @@ ('#(name = Bob)')::jsquery
  #+END_SRC

  #+RESULTS:
  | ?column? |
  |----------|
  | t        |


** Jsquery syntax

*** Simple expression

    ~x = abc~ — value of key ~x~ is equal ~abc~;
    #+BEGIN_SRC sql
      select '{"name": "Bob", "family": "Smith"}'::jsonb @@ ('name = Bob')::jsquery
    #+END_SRC

    ~$ @> [4, 5]~ - the JSON document is an array containing values ~4, 5~;
    #+BEGIN_SRC sql
      select '[1, 2, 3, 4, 5, 6, 7]'::jsonb @@ ('$ @> [1, 4, 8]')::jsquery
    #+END_SRC

    ~abc >= 10~ - value of key ~abc~ is greater than or equal to ~10~;
    #+BEGIN_SRC sql
      select '{"name": "Bob", "age": 55}'::jsonb @@ ('age > 15')::jsquery
    #+END_SRC

    ~volume IS NUMERIC~ - type of key "volume" is numeric.
    Also supports ~IS ARRAY~, ~IS OBJECT~, ~IS STRING~ and ~IS BOOLEAN~.

    #+BEGIN_SRC sql
      select '{"name": "Bob", "age": 55}'::jsonb @@ ('age IS NUMERIC')::jsquery
    #+END_SRC

    ~foo = *~ - key ~foo~ exists in object.
    #+BEGIN_SRC sql
      select '{"name": "Bob", "age": 55}'::jsonb @@ ('name = *')::jsquery
    #+END_SRC

    ~*.color = red~ - there is object somewhere which key "color" has value "red".
    #+BEGIN_SRC sql
      select '{"name": "Bob", "age": 55, "contact": [{"phone": 911}]}'::jsonb @@ ('*.phone = 911')::jsquery
    #+END_SRC

    ~similar_ids.@# > 5~ - ~similar_ids~ is an array or object of length greater than ~5~;
    #+BEGIN_SRC sql
      select '{"contact": [{"phone": 911}, {"email": "foo@com"}]}'::jsonb @@ ('contact.@# > 1')::jsquery
    #+END_SRC

    ~similar_product_ids.# = 0684824396~ - array ~similar_product_ids~ contains string ~0684824396~;
    #+BEGIN_SRC sql
      select '{"name": "Bob", "age": 55}'::jsonb @@ ('age > 15')::jsquery
    #+END_SRC

*** Path select

    ~#~ - any index of array; \\
    ~#:~ - every index of array;
    #+BEGIN_SRC sql
      select '{"contact": [{"phone": 911}, {"email": "foo@com"}]}'::jsonb @@ ('contact.#.phone = 911')::jsquery
    #+END_SRC

    ~#N~ - Nth index of array;
    #+BEGIN_SRC sql
      select '{"contact": [{"phone": 911}, {"email": "foo@com"}]}'::jsonb @@ ('contact.#1.phone = 911')::jsquery
    #+END_SRC

    ~%~ - any key of object; \\
    ~%:~ - every key of object;
    #+BEGIN_SRC sql
      select '{"name": "Bob", "age": 55}'::jsonb @@ ('% = Bob')::jsquery
    #+END_SRC

    ~*~ - any sequence of array indexes and object keys; \\
    ~*:~ - every sequence of array indexes and object keys. \\
    ~$~ - the whole JSON document as single value, could be only the whole path.
    #+BEGIN_SRC sql
      select '{"name": "Bob", "age": 55}'::jsonb @@ ('*($ IS STRING OR $ IS NUMERIC)')::jsquery
    #+END_SRC

* JsonPath

   [[https://www.postgresql.org/docs/13/functions-json.html][JsonPath]] - SQL json standard realization

:zap:Unlike ~JsQuery~, ~JsonPath~ can =extract= and =predicate=

   Set of ~jsonb_path_query*~ functions and ~@@~ operator

   #+BEGIN_SRC sql
     select jsonb_path_query_first('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min && @ <= $max)', '{"min":2, "max":4}')
   #+END_SRC

   #+BEGIN_SRC sql
     select '{"a":[1,2,3,4,5]}' @@ '$.a[*] ? (@ >= 2 && @ <= 5)'
   #+END_SRC


** SQL/JSON Path Language
*** Strict And Lax Modes

 - =lax= (default) — the path engine implicitly adapts the queried data to the specified path.
   Any remaining structural errors are suppressed and converted to empty SQL/JSON sequences.

#+BEGIN_SRC sql
  select jsonb_path_query(resource, 'lax $.name.given')
  from (values ('{"name": [{"given": ["Bob"]}]}'::jsonb)) t(resource)
#+END_SRC


 - =strict= — if a structural error occurs, an error is raised.

#+BEGIN_SRC sql
  select jsonb_path_query(resource, 'strict $.name[*].given')
  from (values ('{"name": [{"given": ["Bob"]}]}'::jsonb)) t(resource)
#+END_SRC


*** Operators and Methods
**** TODO More samples
*** Filter Expression
**** TODO More samples
*** SQL/JSON Regular Expressions
**** TODO More samples

* Json knife

  [[https://github.com/niquola/jsonknife][Json Knife GigHub repository]]
  Useful functions for working with jsonb in PostgreSQL like data extraction, validation & transformation.

** Functions
   ~knife_extract~
   ~knife_extract_text~
   ~knife_extract_numeric~
   ~knife_extract_min_numeric~
   ~knife_extract_max_numeric~
   ~knife_extract_min_timestamptz~
   ~knife_extract_max_timestamptz~
   ~knife_date_bound~

* Class work

Extract jsonb oject keys usuage statistics

** Ansver

#+BEGIN_SRC sql
  with recursive
  keys as
  (
    select jsonb_build_array(key) pth, value
    from "organization", jsonb_each(resource)

    union

    select pth || jsonb_build_array(k), v
    from keys , jsonb_each(value) t(k, v)
    where jsonb_typeof(value) = 'object'

  )
  , total as
  (
    select count(*) ttl from "organization"
  )

  select pth, (count(*)/ttl::float) persent
  from keys, total
  group by pth, ttl
  order by persent desc
#+END_SRC
