#+TITLE: QOPT
#+AUTHOR: M. Surmashev @muradbei
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+PROPERTY: header-args:sql :engine postgresql :dbport 5437 :dbhost localhost :dbuser postgres :dbpassword postgres :database devbox

* Intro                                                            :noexport:

  [[./qopt.jpg]]

* Table of Contents                                                   :TOC_3:
- [[#install-aidbox-dev][Install Aidbox Dev]]
- [[#query][Query]]
- [[#seq-scan][SEQ scan]]
- [[#index-scan][Index scan]]
- [[#bitmap-index-scan][Bitmap Index scan]]
- [[#gin-index][GIN index]]
- [[#join][JOIN]]
  - [[#nested-loop][Nested loop]]
  - [[#hash-join][Hash join]]
  - [[#merge-join][Merge join]]

* Install Aidbox Dev

  Register on [[https://license-ui.aidbox.app/][License Server]]

  Install [[git clone https://github.com/Aidbox/devbox.git][DevBox]]

     #+BEGIN_SRC bash
       git clone https://github.com/Aidbox/devbox.git
       cd devbox
     #+END_SRC

  Copy ~.env.tpl~ to ~.env~

  Insert your =AIDBOX_LICENSE_ID= and =AIDBOX_LICENSE_KEY= in ~.env~ file

  Run ~AidboxDev~

     #+BEGIN_SRC bash
       docker-compose up -d
     #+END_SRC

  Check http://localhost:8888  *Login:* admin *Password:* secret

  Load test data in [[http://localhost:8888/static/console.html?#/rest][RestConsole]]

  #+BEGIN_SRC
POST /fhir/$load

source: 'https://storage.googleapis.com/aidbox-public/school/synthea_all_4.ndjson.gz'
  #+END_SRC

  Vait ~ 20min

  Check upload status in [[http://localhost:878/static/console.html?#/db][DBConsole]]

     #+BEGIN_SRC sql
       SELECT pid, age(clock_timestamp(), query_start), query_start , query
	 FROM pg_stat_activity
	WHERE query != '<IDLE>' AND query NOT ILIKE '%pg_stat_activity%' and "state" = 'active';
     #+END_SRC

     #+RESULTS:
     | query                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
     |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     | with _txid AS (   select nextval('transaction_id_seq') txid ), _inserted AS ( insert into "observation" (id, status, ts, txid, resource) select   distinct on((resource->>'id'))   resource->>'id' as id,   'created' as _status,   current_timestamp as _ts,   (select txid from _txid limit 1) as _txid,   (resource - ARRAY['resourceType', 'id']) as _resource   FROM _import_all   WHERE resource->>'resourceType' = 'Observation'   ON CONFLICT (id)    DO UPDATE SET      resource = EXCLUDED.resource - ARRAY['resourceType', 'id'],                 txid = EXCLUDED.txid,                 status = 'updated',                 ts = EXCLUdED.ts returning id) SELECT count(*) from _inserted |


  Check connection

     #+BEGIN_SRC sql
       select count(*) from patient;
     #+END_SRC

     #+RESULTS:
     | count |
     |-------|
     |  1250 |

* Optimization

 - =Optimize database instance=
   Table space, work_mem, shared_buffers, partitioning, vacuum ...
 - =Optimize query=
   Indexes

* Query

** Standart protocol

   Query execution states

   - ~Parse~ sql string into AST
   - ~Rewrite~ transform query
   - ~Planning~ create exution plan
   - ~Execute~ execute query

   SQL specified what we are want
   Database - how it should be executed

*** Extrra

    #+BEGIN_SRC sql
      alter system set log_parser_stats = on;
    #+END_SRC

    #+RESULTS:
    | ALTER SYSTEM |
    |--------------|

    #+BEGIN_SRC sql
	    alter system set log_plann
      er_stats = on;
    #+END_SRC

    #+RESULTS:
    | ALTER SYSTEM |
    |--------------|

    #+BEGIN_SRC sql
      alter system set log_executor_stats = on;
    #+END_SRC

    #+RESULTS:
    | ALTER SYSTEM |
    |--------------|

    #+BEGIN_SRC sql
      select pg_reload_conf();
    #+END_SRC

    #+RESULTS:
    | pg_reload_conf |
    |----------------|
    | t              |

    #+BEGIN_SRC sql
      explain (analyze)
	select id from patient limit 1;
    #+END_SRC

    #+RESULTS:
    | QUERY PLAN                                                                                               |
    |----------------------------------------------------------------------------------------------------------|
    | Limit  (cost=0.00..0.07 rows=1 width=37) (actual time=0.048..0.078 rows=1 loops=1)                       |
    | ->  Seq Scan on patient  (cost=0.00..82.50 rows=1250 width=37) (actual time=0.031..0.039 rows=1 loops=1) |
    | Planning Time: 2.511 ms                                                                                  |
    | Execution Time: 0.132 ms                                                                                 |

    #+BEGIN_SRC bash :results value pp
      docker logs -n 60 devbox_devbox-db_1 2>&1 | egrep 'LOG|elapsed'
    #+END_SRC

    #+RESULTS:
    #+begin_example
    2021-03-22 16:18:32.607 UTC [1] LOG:  received SIGHUP, reloading configuration files
    2021-03-22 16:18:32.616 UTC [1] LOG:  parameter "log_parser_stats" changed to "on"
    2021-03-22 16:18:32.616 UTC [1] LOG:  parameter "log_planner_stats" changed to "on"
    2021-03-22 16:18:32.616 UTC [1] LOG:  parameter "log_executor_stats" changed to "on"
    2021-03-22 16:18:39.455 UTC [496] LOG:  PARSER STATISTICS
	    !	0.000000 s user, 0.000060 s system, 0.000059 s elapsed
    2021-03-22 16:18:39.455 UTC [496] LOG:  PARSE ANALYSIS STATISTICS
	    !	0.000000 s user, 0.000436 s system, 0.000434 s elapsed
    2021-03-22 16:18:39.455 UTC [496] LOG:  REWRITER STATISTICS
	    !	0.000000 s user, 0.000002 s system, 0.000007 s elapsed
    2021-03-22 16:18:39.458 UTC [496] LOG:  PLANNER STATISTICS
	    !	0.000735 s user, 0.000000 s system, 0.002441 s elapsed
    2021-03-22 16:18:39.461 UTC [496] LOG:  EXECUTOR STATISTICS
	    !	0.001239 s user, 0.000000 s system, 0.005710 s elapsed
    #+end_example


** Extended protocol

   =Prepare statements= - save ast after revrite) -> execute (plan execute) ->
     - ~PREPARE~
     - ~pg_prepared_statements~ view

   =Cursor= - fetch batched data
     - ~DECLARE CURSOR~
     - ~FETCH~

** Query planning

   - Brute force all possible plans (if possible)
     - [[https://postgrespro.ru/docs/postgrespro/12/geqo-pg-intro?lang=en][GEQO]]
   - Plan Estimate
     - Selectivity (statistics)

* SEQ scan

  =Sequential scan=

  #+BEGIN_SRC sql
    explain (analyze, buffers, costs off)
    select ts from patient
    order by ts;
  #+END_SRC

  #+RESULTS:
  | QUERY PLAN                                                            |
  |-----------------------------------------------------------------------|
  | Sort (actual time=21.575..30.906 rows=1250 loops=1)                   |
  | Sort Key: ts                                                          |
  | Sort Method: quicksort  Memory: 107kB                                 |
  | Buffers: shared hit=73                                                |
  | ->  Seq Scan on patient (actual time=0.024..11.093 rows=1250 loops=1) |
  | Buffers: shared hit=70                                                |
  | Planning:                                                             |
  | Buffers: shared hit=76                                                |
  | Planning Time: 2.361 ms                                               |
  | Execution Time: 40.427 ms                                             |


  =Parallel seq scan=

  #+BEGIN_SRC sql
    explain analyze
    select ts from observation;
  #+END_SRC

  #+RESULTS:
  | QUERY PLAN                                                                                                           |
  |----------------------------------------------------------------------------------------------------------------------|
  | Seq Scan on observation  (cost=0.00..64036.59 rows=446859 width=8) (actual time=0.115..3381.321 rows=447093 loops=1) |
  | Planning Time: 5.118 ms                                                                                              |
  | Execution Time: 6382.521 ms                                                                                          |

  #+BEGIN_SRC sql :results value drawer
    explain analyze
    select count(ts) from observation;
  #+END_SRC

  #+RESULTS:
  :results:
  QUERY PLAN
  Finalize Aggregate  (cost=62895.60..62895.61 rows=1 width=8) (actual time=2044.017..2056.143 rows=1 loops=1)
    ->  Gather  (cost=62895.39..62895.60 rows=2 width=8) (actual time=2043.893..2056.092 rows=3 loops=1)
	  Workers Planned: 2
	  Workers Launched: 2
	  ->  Partial Aggregate  (cost=61895.39..61895.40 rows=1 width=8) (actual time=2033.642..2033.667 rows=1 loops=3)
		->  Parallel Seq Scan on observation  (cost=0.00..61429.91 rows=186191 width=8) (actual time=0.017..1018.168 rows=149031 loops=3)
  Planning Time: 3.393 ms
  Execution Time: 2056.290 ms
  :end:


  #+BEGIN_SRC sql
    show  max_parallel_workers_per_gather
  #+END_SRC

  #+RESULTS:
  | max_parallel_workers_per_gather |
  |---------------------------------|
  |                               2 |

  #+BEGIN_SRC
    max_parallel_workers_per_gather = 2
    max_parallel_workers = 8
    max_worker_processes = 8
  #+END_SRC

* Index scan

  =Index scan= / =Index only scan=

  #+BEGIN_SRC sql :results value
    \d+ patient
  #+END_SRC

  #+RESULTS:
  | Table "public.patient"                 |                          |           |          |                   |          |              |             |
  |----------------------------------------+--------------------------+-----------+----------+-------------------+----------+--------------+-------------|
  | Column                                 | Type                     | Collation | Nullable | Default           | Storage  | Stats target | Description |
  | id                                     | text                     |           | not null |                   | extended |              |             |
  | txid                                   | bigint                   |           | not null |                   | plain    |              |             |
  | cts                                    | timestamp with time zone |           |          | CURRENT_TIMESTAMP | plain    |              |             |
  | ts                                     | timestamp with time zone |           |          | CURRENT_TIMESTAMP | plain    |              |             |
  | resource_type                          | text                     |           |          | 'Patient'::text   | extended |              |             |
  | status                                 | resource_status          |           | not null |                   | plain    |              |             |
  | resource                               | jsonb                    |           | not null |                   | extended |              |             |
  | Indexes:                               |                          |           |          |                   |          |              |             |
  | "patient_pkey" PRIMARY KEY, btree (id) |                          |           |          |                   |          |              |             |
  | Access method: heap                    |                          |           |          |                   |          |              |             |


  #+BEGIN_SRC sql :results value drawer
    explain analyze
     select resource
       from patient
      where id = '176121b8-3f42-0ef6-75c5-a71778bc32d9';
  #+END_SRC

  #+RESULTS:
  :results:
  QUERY PLAN
  Index Scan using patient_pkey on patient  (cost=0.28..8.29 rows=1 width=320) (actual time=0.108..0.125 rows=1 loops=1)
    Index Cond: (id = '176121b8-3f42-0ef6-75c5-a71778bc32d9'::text)
  Planning Time: 2.656 ms
  Execution Time: 0.230 ms
  :end:

  #+BEGIN_SRC sql
    explain analyze
     select id
       from patient
      where id = '176121b8-3f42-0ef6-75c5-a71778bc32d9';
  #+END_SRC

  #+RESULTS:
  | QUERY PLAN                                                                                                                 |
  |----------------------------------------------------------------------------------------------------------------------------|
  | Index Only Scan using patient_pkey on patient  (cost=0.28..4.29 rows=1 width=37) (actual time=1.514..1.530 rows=1 loops=1) |
  | Index Cond: (id = '176121b8-3f42-0ef6-75c5-a71778bc32d9'::text)                                                            |
  | Heap Fetches: 0                                                                                                            |
  | Planning Time: 6.438 ms                                                                                                    |
  | Execution Time: 1.598 ms                                                                                                   |


** What about JSONB?

   =Task 1= - find Patient with phohe  ~555-636-7428~

   #+BEGIN_SRC sql :results value drawer
     explain analyze
       select id, resource->'telecom'
       from patient
       where resource#>>'{telecom,0,value}' = '555-636-7428';
   #+END_SRC

   #+RESULTS:
   :results:
   QUERY PLAN
   Index Scan using patien_phone on patient  (cost=0.28..8.30 rows=1 width=69) (actual time=0.178..0.200 rows=1 loops=1)
     Index Cond: ((resource #>> '{telecom,0,value}'::text[]) = '555-636-7428'::text)
   Planning Time: 4.177 ms
   Execution Time: 0.294 ms
   :end:

1 2 3 4 5 6 7 8 9


    3,       5,   8
  |       |     |   |
1->2->3  4->5  7->8 9

   #+BEGIN_SRC sql
     create index patien_phone on patient ((resource#>>'{telecom,0,value}'));
   #+END_SRC

   #+BEGIN_SRC sql
     vacuum analyze patient;
   #+END_SRC

   #+BEGIN_SRC sql
     drop index patien_phone;
   #+END_SRC


*** Extra

  parallel index scan
    min_parallel_index_scan
    parallel_workers (for table)


* Bitmap Index scan


  Bitmap index scan
   where select from index return too many rows
   and data order by random
  Parallel Bitmap Heap Scan

  BitmapOr
  BitmapAnd


  =Task 3= - find 5 most older patients


  #+BEGIN_SRC sql :results value drawer
    explain analyze
      select id, resource#>>'{birthDate}'
      from patient
      where resource#>>'{birthDate}' > '2000-01-01'
            and resource->'telecom'#>>'{0,value}' > '555-408-5373'
      --order by resource#>>'{birthDate}'
#+END_SRC

#+RESULTS:
:results:
QUERY PLAN
Bitmap Heap Scan on patient  (cost=9.98..85.20 rows=75 width=69) (actual time=0.154..5.886 rows=149 loops=1)
  Recheck Cond: ((resource #>> '{birthDate}'::text[]) > '2000-01-01'::text)
  Filter: (((resource -> 'telecom'::text) #>> '{0,value}'::text[]) > '555-408-5373'::text)
  Rows Removed by Filter: 81
  Heap Blocks: exact=70
  ->  Bitmap Index Scan on patient_bd  (cost=0.00..9.96 rows=224 width=0) (actual time=0.069..0.076 rows=230 loops=1)
        Index Cond: ((resource #>> '{birthDate}'::text[]) > '2000-01-01'::text)
Planning Time: 6.089 ms
Execution Time: 7.165 ms
:end:

#+BEGIN_SRC sql
vacuum analyze patient
#+END_SRC

#+RESULTS:
| VACUUM |
|--------|

#+BEGIN_SRC sql
\d+ patient
#+END_SRC

#+RESULTS:
| Table "public.patient"                                            |                          |           |          |                   |          |              |             |
|-------------------------------------------------------------------+--------------------------+-----------+----------+-------------------+----------+--------------+-------------|
| Column                                                            | Type                     | Collation | Nullable | Default           | Storage  | Stats target | Description |
| id                                                                | text                     |           | not null |                   | extended |              |             |
| txid                                                              | bigint                   |           | not null |                   | plain    |              |             |
| cts                                                               | timestamp with time zone |           |          | CURRENT_TIMESTAMP | plain    |              |             |
| ts                                                                | timestamp with time zone |           |          | CURRENT_TIMESTAMP | plain    |              |             |
| resource_type                                                     | text                     |           |          | 'Patient'::text   | extended |              |             |
| status                                                            | resource_status          |           | not null |                   | plain    |              |             |
| resource                                                          | jsonb                    |           | not null |                   | extended |              |             |
| Indexes:                                                          |                          |           |          |                   |          |              |             |
| "patient_pkey" PRIMARY KEY, btree (id)                            |                          |           |          |                   |          |              |             |
| "patien_phone" btree ((resource #>> '{telecom,0,value}'::text[])) |                          |           |          |                   |          |              |             |
| "patient_bd" btree ((resource #>> '{birthDate}'::text[]))         |                          |           |          |                   |          |              |             |
| Access method: heap                                               |                          |           |          |                   |          |              |             |

#+BEGIN_SRC sql
  create index patient_bd on patient ((resource#>>'{birthDate}'));
#+END_SRC


#+BEGIN_SRC sql
vacuum analyze patient
#+END_SRC

#+RESULTS:
| VACUUM |
|--------|

  Bitmap AND/OR

  Task 4 - Phone start with 555-8 and older then 50

#+BEGIN_SRC sql
select '555-8' > '555-715-1598'
#+END_SRC


#+BEGIN_SRC sql
select '101' > '10'
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
| f        |

#+BEGIN_SRC sql
select '101' like '10%'
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
| t        |


* GIN index

 #+BEGIN_SRC json
      PID: 1
      {
	  "code": "911",
	  "display": "9",
	  "system": "http://loinc.org"
      }

      PID: 2
      {
	  "code": "8",
	  "system": "http://loinc.org"
      }


      GIN
code   : [1, 2] system : [1, 2]
      9 : [1]
      8 : [2]
      http://loinc.org [1, 2]
      display: [1]
      911: [1]


   @? '{"code": "9"}'

   code -> [1, 2]
   9   -> [1]
   = [1]


 #+END_SRC


  Gin index scan
  recheck and filter

  jsonpath / gin and > >=


  =Task 4= - How much Blood Pressure observations?

  #+BEGIN_SRC sql :results value drawer
	explain analyze
	  select id
	  from observation
	  where
    resource->'category' @> '{"coding": [{"code": "85354-9", "system": "http://loinc.org", "display": "Blood Pressure"}]}'::jsonb
and
    resource->'code' @> '{"coding": [{"code": "85354-9", "system": "http://loinc.org", "display": "Blood Pressure"}]}'::jsonb

  #+END_SRC

@>  @@ jsquery/jsonpath

  #+RESULTS:
  :results:
  QUERY PLAN
  Bitmap Heap Scan on observation  (cost=268.46..445.65 rows=45 width=37) (actual time=0.480..0.504 rows=0 loops=1)
    Recheck Cond: (((resource -> 'code'::text) @> '{"coding": [{"code": "85354-9", "system": "http://loinc.org", "display": "Blood Pressure"}]}'::jsonb) AND ((resource -> 'category'::text) @> '{"coding": [{"code": "85354-9", "system": "http://loinc.org", "display": "Blood Pressure"}]}'::jsonb))
    ->  Bitmap Index Scan on observation_resource_code_category__gin_jsquery  (cost=0.00..268.45 rows=45 width=0) (actual time=0.464..0.472 rows=0 loops=1)
	  Index Cond: (((resource -> 'code'::text) @> '{"coding": [{"code": "85354-9", "system": "http://loinc.org", "display": "Blood Pressure"}]}'::jsonb) AND ((resource -> 'category'::text) @> '{"coding": [{"code": "85354-9", "system": "http://loinc.org", "display": "Blood Pressure"}]}'::jsonb))
  Planning Time: 5.268 ms
  Execution Time: 0.727 ms
  :end:


  #+BEGIN_SRC json
    {
	"code": "85354-9",
	"system": "http://loinc.org",
	"display": "Blood Pressure"
    }
  #+END_SRC

  #+BEGIN_SRC sql
    create index observation_resource__gin_jsquery
      on observation using gin ((resource) jsonb_path_value_ops)
  #+END_SRC


  #+BEGIN_SRC sql
    create index observation_resource_code_category__gin_jsquery
      on observation using gin ((resource->'code'), (resource->'category') jsonb_path_value_ops)
  #+END_SRC

  #+RESULTS:
  | CREATE INDEX |
  |--------------|


#+BEGIN_SRC sql
vacuum analyze observation
#+END_SRC

  #+RESULTS:
  |   |


@> gin
jsquery  jsonb_path_value_ops

jsonpath
 gin
jp + ?  jsonb_ops
ilike gin_trgm_ops tsvector ... / RUN index
-----
@> and jsquery


create index patient_resource__gin_jsquery
on patient using gin ((resource) jsonb_path_value_ops);


Ilike

create index if not exists
patient_resource__gin_tgrm on patient
using gin ((id || '' || resource::text) gin_trgm_ops);






* JOIN

  not left/right/inner BUT join methods


  always pair


** Nested loop
   JOIN cost N*M
   Nested loop
   Nested loop Left Join
   Nested loop anti join
     jeft join is null (not exists)
   Nested loop semi join
     (exists)

  + No prepare actions
  + Good for less data
  + Depends on join order
  + Any condition (also <>)

** Hash join
** Merge join
